Current:
    Wrote sym_same_op for comb and adj
    Want to test it
    Comm=False, same_op=False broken in spec_synth test
        Bug in Pattern equality.
    Fixed pattern Equality
    Comb.sym_same_op works
    Adj.sym_same_op works
    Done on P_sym_same_op




Goal: 4/9: Optimize for results for presentation
    GOAL:
        for (simple isa, complex isa):
            Pre-filter perf better than post filter perf.
            Quality of instruction selection are at least matched.
    TASKS
        -Choose single application to do instruction selection on/gen rules for
        -Update codebase to have have a CBV type and allow BV[0].
        -Choose and serialize complex isa so that it is complete with DSE (feel free to hack). ... I want it in comb form to serialize.
        -get the pre-filtering code working again for Comb
        -get post-filtering code working (with post-filtering)
        -Add timing decorators to the codebase
        -Get the actual numbers for that simple example in a real table.
        -Write instruction selection:
            - I can just manually write the application in Comb form.
    Issues to handle:
        Two ways to filter searches.
        If I already have a semantically matching pattern on the left. I can exclude superset patterns on right
        Similarly if I have a semantically matching pattern on the right, I can exclude smaller patterns on left (might not be true)
        What if I had some basic 'const instruction' parameterization in the ISA block? I could imagine something like programming adding 1 or 0

    Work queue:
        Get a better flow for logging results
        Write full instruction selection.
            Create a Match logger
            Could leverage for rewrite rule uniqueness
            Would allow for getting real results for certain applications
        Idea: Excluding commutative Programs could be simply adding input_perm constraint to the rhs
            But input_perm parameterized over the commutative args. Similar to a constraint to remove extra program orders
        Write Preemptive Generative Filtering

        Write Incremental Generative Filtering
            Verify by it passing the wfp constraints
            I could do the naive enumeration and just filter based off if it passes the other kind of constraints.

        ISSUE: The ordering must be fucked up. I am first generating a rewrite rule for Sub(x,x)=0 and that is excluding generating rules for (sub(x,y))

    DONE
        Work on add_rule_cover
        Fixed generate all rule covers based on cost.
        Smart iteration based on cost (low to high)
        Write the generalization of commutativity
        I can only timeout on individual calls to sat. Very annoying and slow
        Rule filtering is broken. Rule equality does not work correctly.
        Problem: Multiple matches can occur with commutivity. I cannot do an eager break. Fix it
        Pattern equality/matching does not work for the case on the baord
        Get comm_synth working
        Post filtering works
        Ill just time CEGIS
        I need to add logging somehow (to stdout for now)
        add timing decorators for SMT calls
        add max op filter to RuleSynth call
        write postfiltering
        write the ISA by hand for conv
        Add pound comments in yacc
        Add CBV type. DONE
        Add synth test for CBV
        update CombSynth to use (n, const)

Idea to handle Constants.


Task List:
	Required:
		DepthEncoding.P_sym_input_perm
		#Starting a Paper Overleaf
		Rule Synth with Spec Synth:
		Update Rules to include lists of Patterns

		Composition matching but adhere to syms
		I also need to actually write the damn paper. When am I going to do that???
		I should get it done in the next 2 weeks ideally…?

		Read the papers referenced in Clarks’ target.
		Explicity write out the experiments that I want to run.
		Experiments:
			Comparison of different methods
		Main Results:
			Pre-filtering is more efficient than post-filtering
				Do for Spec Synth and Rule Synth.
				Rule
			Perf comparison between the 3 Encodings:
			Effect of each symmetry (When you turn them off and on)
			Actually perform instruction selection on real CoreIR graphs with real rules.

	Features:
		Update commutativity to be general
		Determine commutativity of spec automatically

Focus on 1 -> M
         N -> M
         N -> 1

Pick 3 titles with 3 abstracts.


Program synthesis


2 Different papers.


Fix CoreIR to be the IR.


Pick a Contrived Instruction Set.


Real simple PE vs Real complex PE


I designed 2 PEs.


Making the case for the different encodings